# 类型系统与编译原理入门

> 💡 **学习指南**：当你写下 `int x = 10 + 5;` 时，编译器是如何理解每个字符、检查类型是否正确、最终生成机器指令的？本章用两个核心概念——**类型系统**和**编译流程**——帮你理解编程语言背后的"翻译机制"。

---

## 0. 想象你是翻译官

翻译一本书，你需要：

1. **识别单词** — 把句子拆成一个个单词（词法分析）
2. **理解语法** — 判断句子是否符合语法规则（语法分析）
3. **理解含义** — 确保句子意思正确，类型不冲突（语义分析）
4. **优化表达** — 让句子更简洁流畅（代码优化）
5. **翻译输出** — 翻译成目标语言（代码生成）

**编译器就是编程语言的"翻译官"**，将你写的代码转换为机器能执行的指令。而**类型系统**就是翻译过程中的"语法检查器"——确保你不会把数字当文字用。

---

## 1. 类型系统：数据的交通规则

👇 动手点点看：探索四种类型系统的区别

<TypeSystemDemo />

::: tip 💡 一句话总结
类型系统在两个维度上做选择：**何时检查**（编译时 vs 运行时）和**是否允许隐式转换**（强类型 vs 弱类型）。没有最好的组合，只有最适合的场景。
:::

---

### 1.1 静态类型 vs 动态类型

| | 静态类型 | 动态类型 |
|---|---|---|
| **检查时机** | 编译时（还没运行就检查） | 运行时（跑到那行才检查） |
| **发现 bug** | 早（写完就知道） | 晚（用户操作时才暴露） |
| **灵活性** | 较低（类型固定） | 较高（类型可变） |
| **IDE 支持** | 好（自动补全、重构） | 差（运行时才知道类型） |
| **代表** | Java, TypeScript, Rust | Python, JavaScript, Ruby |

### 1.2 强类型 vs 弱类型

**核心区别**：`"1" + 1` 会发生什么？

- **强类型（Python）**：直接报错 `TypeError` — "你得明确告诉我怎么转"
- **弱类型（JavaScript）**：悄悄转成 `"11"` — "我猜你想拼字符串"

弱类型的"好意"常常带来意想不到的 bug。

### 1.3 类型推断：两全其美

现代语言的类型推断让你**写着像动态语言，编译器检查像静态语言**：

```typescript
let x = 1           // 编译器自动推断为 number
let arr = [1, 2, 3] // 推断为 number[]
x = "hello"         // ❌ 编译错误！类型不匹配
```

你不用显式写类型声明，编译器也能帮你严格检查。

---

## 2. 编译流程：从代码到机器码

👇 动手点点看：输入代码，观察编译器的六步翻译过程

<CompilerDemo />

::: tip 💡 一句话总结
编译器的六步流水线：源代码 → Token（词法分析）→ AST（语法分析）→ 带类型的 AST（语义分析）→ IR（中间代码）→ 优化后的 IR → 机器码。
:::

---

### 2.1 词法分析：拆出每个"单词"

```
源代码: int x = 10 + 5;

Token 流:
[int]   → 关键字
[x]     → 标识符
[=]     → 运算符
[10]    → 数字
[+]     → 运算符
[5]     → 数字
[;]     → 分隔符
```

### 2.2 语法分析：构建语法树（AST）

```
表达式: 1 + 2 * 3

语法树:        为什么？
       +       因为 * 的优先级
      / \      高于 +，所以
     1   *     2 * 3 先结合
        / \
       2   3
```

### 2.3 语义分析：检查"意思"是否正确

| 检查内容 | 示例 | 结果 |
|---|---|---|
| 类型检查 | `int x = "hello"` | ❌ 类型不匹配 |
| 作用域分析 | 使用未声明的变量 | ❌ 变量不存在 |
| 类型推断 | `1 + 2.0` | ✅ 推断为 float |

### 2.4 代码优化：让程序跑得更快

| 优化技术 | 优化前 | 优化后 |
|---|---|---|
| 常量折叠 | `x = 10 + 5` | `x = 15` |
| 死代码消除 | `if (false) { ... }` | 直接删除 |
| 常量传播 | `y = x * 2`（x=15） | `y = 30` |

---

## 3. 编译型 vs 解释型 vs JIT

程序写完后，有三种"翻译方式"让它运行：

| | 编译型 | 解释型 | JIT 即时编译 |
|---|---|---|---|
| **过程** | 先编译成机器码，再执行 | 边读边执行 | 先解释，热点代码再编译 |
| **速度** | 最快 | 最慢 | 中等（热点代码接近编译型） |
| **启动** | 慢（需编译） | 快（直接运行） | 中等（需预热） |
| **跨平台** | 需要重新编译 | 天然跨平台 | 跨平台 |
| **代表** | C, Rust, Go | Python, Ruby | Java, JavaScript (V8) |

::: tip 💡 为什么 JavaScript 这么快？
V8 引擎的 JIT 编译器会监测哪些代码被频繁执行（热点代码），然后把它们编译成高度优化的机器码。所以虽然 JavaScript 是"解释型语言"，但在 V8 中它的性能可以接近编译型语言。
:::

---

## 4. 总结

::: tip 📚 核心要点
1. **类型系统**：静态/动态决定检查时机，强/弱决定是否允许隐式转换
2. **编译六步**：词法分析 → 语法分析 → 语义分析 → 中间代码 → 优化 → 代码生成
3. **三种执行**：编译型快但需编译，解释型灵活但慢，JIT 兼顾两者
4. **类型推断**：现代语言让你享受动态语言的简洁和静态语言的安全
:::

**下一步学习**：
- [编程语言图谱](./programming-languages) - 了解更多编程语言
- [数据结构](./data-structures) - 理解数据的组织方式
- [算法思维入门](./algorithm-thinking) - 学习解决问题的方法
